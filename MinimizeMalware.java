// TC: O(n^2)
// SC: O(n)

// Approach: Color code groups. Find groups with only a single
// infected node. Whatever group has most nodes will have the answer.
// If no group has a single infected node, choose the infected node with
// the lowest value

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class MinimizeMalware {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] nodesGroup = new int[n];
        Arrays.fill(nodesGroup, -1);

        Set<Integer> infected = new HashSet<>();
        List<Integer> groupCount = new ArrayList<>();
        List<Integer> infectedGroupCount = new ArrayList<>();

        int smallestInfectedNode = initial[0];
        for (int node : initial) {
            infected.add(node);
            smallestInfectedNode = Math.min(smallestInfectedNode, node);
        }

        int currentGroup = 0;
        for (int i = 0; i < n; i++) {
            // already visited
            if (nodesGroup[i] != -1) {
                continue;
            }

            groupCount.add(0);
            infectedGroupCount.add(0);
            // nodesGroup also acts as visited arr
            dfs(graph, i, currentGroup, nodesGroup, groupCount, infectedGroupCount, infected);
            currentGroup++;
        }

        int res = -1;
        int resNode = initial[0];

        for (int node : initial) {
            int group = nodesGroup[node];
            if (infectedGroupCount.get(group) != 1) {
                continue;
            }
            // group has exactly one infected node
            int nodesSaved = groupCount.get(group) - 1;
            if (nodesSaved == res && node < resNode) {
                resNode = node;
            }
            if (nodesSaved > res) {
                res = nodesSaved;
                resNode = node;
            }
        }

        return res == -1 ? smallestInfectedNode : resNode;
    }

    public void dfs(int[][] graph, int node, int currentGroup, int[] nodesGroup, List<Integer> groupCount,
            List<Integer> infectedGroupCount, Set<Integer> infected) {
        int lastGroup = groupCount.size() - 1;
        groupCount.set(lastGroup, groupCount.get(lastGroup) + 1);
        if (infected.contains(node)) {
            infectedGroupCount.set(lastGroup, infectedGroupCount.get(lastGroup) + 1);
        }

        // assign group
        nodesGroup[node] = currentGroup;

        for (int i = 0; i < graph[node].length; i++) {
            // connection exists and not in visited
            if (graph[node][i] == 1 && nodesGroup[i] == -1) {
                dfs(graph, i, currentGroup, nodesGroup, groupCount, infectedGroupCount, infected);
            }
        }
    }
}